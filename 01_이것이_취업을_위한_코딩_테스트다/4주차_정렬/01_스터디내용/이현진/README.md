# 3주차 개념 : 기준에 따라 데이터를 정렬
## 1. 정렬이란
+ 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
+ 이진 탐색(Binary Search)의 전처리 과정
+ 오름차순 -> 내림차순 으로의 변환은 뒤집기(Reverse)를 하면되는데, 뒤집기 연산의 수행복잡도는 O(N)
---------------

## 2. 정렬의 유형
+ 선택정렬
    + 처리되지 않은 데이터 중 가장 작은 데이터를 선택하여, 처리되지 않은 데이터 중 첫번째 데이터와 교환
    + 위의 과정을 N(데이터의 개수) - 1 번 반복하면 모든 데이터가 정렬
    + 과정
        + 처리되지 않은 데이터 중 첫번째 데이터 인덱스 지정 -> min
        + min 그 다음의 인덱스(min+1) 부터 차례대로 min번째 데이터와 비교하여 더 작으면 swap
    + 코드
    ```Python
    arr = [7,5,9,0,3,1,6,2,4,8]
    for i in range(len(arr)):
        min = i
        for j in range(i+1, len(arr)): 
            if arr[min] > arr[j]:
                min = j 
                arr[min], arr[i] = arr[i], arr[min]
    ``` 
    + 시간복잡도
        + (N-1)번 비교연산을 수행 -> O(N^2) 
        + 데이터의 개수가 10,000개 이상이되면 매우 비효율적
        + 다른 알고리즘과 함께 특정 리스트(데이터가 10,000개 이하)에서 가장 작은 데이터를 찾을 때는 사용
+ 삽입정렬
    + 뒤지는 데이터 이전의 데이터들이 이미 정렬되어 있다는 가정하에 정렬 수행 -> 두번째 인덱스부터 정렬 시작
    + 이미 정렬된 데이터를 비교하여 처리할 데이터의 위치를 찾으면 반복 중단 -> 정렬이 많이 된 데이터들에서 효율적
    + 과정
        + 두번째~마지막 인덱스까지 차례대로 이미 정렬된 데이터와 비교(첫번째는 이미 정렬되었다고 가정)
        + 비교한 데이터의 위치를 찾으면 그 자리에 삽입후, 반복중단
        + 위의 과정을 (N-1)번 반복하면 정렬
    + 코드
    ```Python
    arr = [7,5,9,0,3,1,6,2,4,8]
    for i in range(1,len(arr)): #두번째 인덱스부터 시작
        for j in range(i,0,-1): #이미 정렬된 데이터를 뒤진다
            if arr[j] < arr[j-1]:
                arr[j], arr[j-1] = arr[j-1], arr[j]
            else: #위치를 찾으면 반복중단
                break
    ``` 
    + 시간복잡도
        + (N-1)번 비교연산을 수행 -> O(N^2) 
        + 이미 정렬이 많이 수행된 데이터들의 경우 -> O(N)
        + 일반적으로는 삽입정렬과 마찬가지로 데이터의 개수가 10,000개 이상이면 비효율적
        + 그러나 거의 정렬되어 있는 데이터들을 정렬할 때는 퀵정렬보다 효율적
+ 퀵 정렬
    + 기준데이터(PIVOT)를 정하고 그 데이터보다 작은 데이터와 큰 데이터 교환후, 피벗의 위치를 기준으로 리스트 분할
    + 위의 과정을 모든 데이터가 정렬될 때까지 반복
    + 과정
        + 리스트의 첫번째 데이터 == PIVOT
        + 리스트 왼쪽부터 피벗보다 큰데이터를 찾고, 리스트의 오른쪽부터 피벗보다 작은 데이터를 찾는다
        + 왼쪽 인덱스와 오른쪽 인덱스가 서로 엇갈리면 중단 -> 엇갈린 두 인덱스의 데이터 중 작은 데이터와 피벗 교환
        + 피벗을 기준으로 리스트 분할
        + 위의 과정 정렬완료때까지 반복
    + 코드
    ```Python
    arr = [7,5,9,0,3,1,6,2,4,8]
    def quickSort(arr, start, end):
      if start >= end: #데이터의 개수가 1개이면 종료
        return
      
      pivot = start  #리스트의 첫번째 데이터 == 피벗
      left = start+1 #피벗의 오른쪽부터 피벗보다 큰 데이터 탐색
      right = end    #리스트의 마지막부터 피벗보다 작은 데이터 탐색

      while left <= right: #탐색 인덱스 두개가 교차할때 반복중단
        while left <= end and arr[left] <= pivot: #왼쪽 탐색 데이터는 피벗보다 큰 데이터 탐색
          left += 1
        while right > start and arr[right] >= pivot: #오른쪽 탐색 데이터는 피벗보다 작은 데이터 탐색
          right -= 1
        
      if left > right: #두 탐색조가 엇갈렸다면 작은 데이터와 피벗 교체
        arr[pivot], arr[right] = arr[right], arr[pivot]
      else: #탐색조가 엇갈리지 않았다면 작은데이터와 큰 데이터 교체
        arr[left], arr[right] = arr[right], arr[left]
      
      #분할 이후 왼쪽과 오른쪽 리스트에서 퀵정렬 반복
      quickSort(arr, start, right-1)
      quickSort(arr, right+1, start)
    
    quickSort(arr, 0, len(arr)-1)

    #파이썬의 장점을 살린 코드
    arr = [7,5,9,0,3,1,6,2,4,8]

    def quickSort(arr):
      if len(arr) <= 1:
        return
      
      pivot = arr[0] #리스트의 첫번째 요소 == 피벗
      tail = arr[1:] #피벗을 제외한 나머지 데이터 모두

      left_arr =  [x for x in tail x <= pivot] #나머지 데이터 중 피벗보다 작거나 같은 데이터들
      right_arr = [x for x in tail x > pivot]  #나머지 데이터 중 피벗보다 큰 데이터틀

      return quickSort(left_arr) + [pivot] + quickSort(right_arr) #리스트 형태로 반환
    
    quickSort(arr)
    ``` 
    + 시간복잡도
        + 평균 시간복잡도 == O(N log N)
        + 이미 거의 정렬된 경우 시간복잡도 == O(N^2)
        + 이미 거의 정렬된 경우 굉장히 유리해지는 삽입정렬과 반대
+ 계수정렬
+ 
    + 과정
        + 특정한 조건에 부합하는 리스트의 데이터들을 정렬할 떄 매우 효과적
          + 조건 1. 모든 데이터가 정수
          + 조건 2. 데이터의 개수 <= 1,000,000
        + 데이터크기의 범위만큼의 리스트를 생성하여 각 인덱스를 데이터의 값이라고 가정
        + 해당 인덱스와 동일한 값의 데이터가 나오면 해당 인덱스의 값 +1
    + 코드
    ```Python
    arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

    count = [0] * (max(arr)+1) #모든 데이터의 크기가 0이상일때, 가장큰 데이터값 + 1(0만큼) 사이즈의 카운트 리스트 초기화

    for i in range(len(arr)):
      count[arr[i]] += 1 #카운트 리스트의 인덱스 == 정렬할 데이터의 값
    ``` 
    + 복잡도
        + 시간복잡도 : O(N + K) (O(N)) -> 조건에만 부합하면 아주 효과적
        + 공간복잡도 : O(N + K) -> 데이터의 크기 범위가 <= 1,000,000 이하일 때만 -> 이중에서도 반복되는 데이터가 많은 경우
---------------

## 3. 파이썬이 제공하는 기본 정렬 라이브러리
+  sorted(arr) 
  + 정렬 라이브러리가 제공
  + 반환값은 어떤 데이터를 넣어도 항상 리스트
+ arr.sort()
  + 리스트 객체의 내장함수
  + 반환값은 없다
+ sorted() 와 sort() : 파이썬이 제공하는 정렬 라이브러리
  + 병합정렬을 기반으로 이루어져있다 -> 퀵정렬보다는 느리지만 최악의 경우에도 O(N log N)을 보장한다
  + 매개변수
    + reverse=True : 내림차순으로 정렬
    + key=정렬기준이될함수 : 해당 기준 함수에 따라 정렬
    + EX.
    ```Python
    arr = [('바나나',7), ('사과',2), ('오렌지', 4)]

    def setting(data):
      return data[1]

    #setting 이라는 정렬의 기준이 될 함수는 어떠한 자료형을 받아 그 자료형의 인덱스가 1인 데이터들을 반환한다
    #따라서 key 값은 setting으로 잡을 경우, 정렬할 데이터의 1번째 인덱스의 데이터들을 기준으로 정렬할 것이다
    #아래의 코드에서는 튜플의 1번째 원소들인 정수에 따라 정렬할 것이다
    arr.sort(key, key=setting)
    sort(arr, ket=setting) 
    ```
------------

## 4. 선택정렬 vs 삽입정렬
+ 이중 반복문을 돌며 데이터를 비교하여 교환한다는 원리는 동일
+ 차이점
    + 선택정렬은 처리되지 않은 모든 데이터를 확인 -> 처리되지 않은 데이터를 뒤진다 
    + 삽입정렬은 처리된 데이터 중 위치를 찾으면 중단 -> 처리된 데이터를 뒤진다
---------------

## 5. 정렬 알고리즘들
+ 어떤 정렬 알고리즘이 효과적??
  + 일반적으로 여러가지 상황상 코딩테스트에서는 웬만해선 데이터의 개수는 10,000,000개 미만
  + 상황 1. 일반적으로 단순히 데이터를 정렬할 필요가 있을때 : 라이브러리 사용(sorted(), sort())
  + 상황 2. 보다 정렬 알고리즘에 대한 원리가 필요할 때 : 삽입->거의 정렬된 데이터 , 퀵->정렬이 거의 되어있지 않고 개수가 많을때 , 선택
  + 상황 3. 더 빠른 정렬이 필요할 때 : 퀵으로 안되는 경우 -> 조건에 맞으면 계수 , 그렇지 않으면 기존의 정렬 알고리즘의 구조적 개선 필요