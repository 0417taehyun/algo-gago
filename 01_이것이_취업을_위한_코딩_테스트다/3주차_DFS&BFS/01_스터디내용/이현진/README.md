# 3주차 개념 : DFS/BFS

## 1. 꼭 필요한 자료구조
+ 탐색(search)
+ 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
+ 그 중에서도 그래프, 트리 탐색이 존재하는데 그 알고리즘은 DFS/BFS로 풀이
+ 해당 알고리즘을 이해하기 위한 선수지식은 스택, 큐, 재귀함수
---------------

+ 스택(stack)
+ 후입선출(LIFO)
+ 대표적인 연산 함수로는 삽입(), 삭제() 수행
+ Python에서는 단순히 리스트 자료형을 이용하여 스택 구현
  리스트 자료형이 이미 append(), pop() 함수를 제공하기 떄문
---------------

+ 큐(queue)
+ 선입선출(FIFO)
+ 대표적인 연산 함수로는 삽입(), 삭제() 수행
+ deque 라이브러리를 이용하여 구현 
  append()를 통해 삽입, popleft()를 이용하여 가장 왼편(가장 먼저 삽입된) 데이터를 삭제
+ 결과를 리스트 자료형으로 반환하기 위해서는 list() 사용
---------------

+ 재귀함수(recusive function)
+ 자기자신을 호출하는 함수
+ 종료 조건을 꼭 명시할 필요
+ 내부적으로 스택과 동일한 원리
  가장 마지막에 호출된 함수부터 차례로 종료시켜야 함
---------------

## 2. 그래프의 구조 표현
+ 그래프의 구조로 표현한 후, 스택/큐/재귀함수를 통해 탐색을 진행
+ 그래프의 구조는 노드와 간선으로 표현
+ 인접행렬(adjacent matrix) : 2차원 배열로 그래프의 연결관계를 표현
    + 간선으로 서로 연결되어 있지 않은 노드끼리는 무한(INF)으로 표현
      이때 무한한 값은 논리적으로 정답이 될 수 없는 큰 값으로 표현 Ex. 999999999
    + 인접 행렬로 표현한 그래프 예시
    ```Python
    INF = 999999999 #무한한 값을 상수로 미리 표현

    #노드 0,1,2 순으로 0-1사이의 간선의 길이가 7, 0-2사이의 간선의 길이가 5인 그래프
    graph = [
        [0, 7, 5],
        [7, 0, INF],
        [5, INF, 0]
    ]
    ```
+ 인접그래프(adjacent graph) : 리스트로 그래프의 연결관계를 표현
    + 2차원 리스트로 표현
      첫번째 리스트의 원소는 노드의 순으로 나열
      이후의 두번째 리스트에는 연결된 노드와 간선의 길이를 튜플로 표현
    + 인접 리스트로 표현한 그래프 예시
    ```Python
    graph = [[] for _ in range(3)] #노드의 개수만큼 반복하며 2차원 리스트 생성

    graph[0].append((1,7))
    graph[0].append((2,5))
    graph[1].append((0,7))
    graph[2].append((0,5))
    ```
+ 인접행렬은 연결되지 않아도 표현해야하기 때문에 불필요한 메모리 낭비 발생 -> 메모리 비효율성
+ 인접리스트는 연결된 정보만을 저장하기 때문에 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림 -> 속도 비효율성
---------------

## 3. DFS(Depth-First Search)
+ 깊이 우선 탐색
+ 구현방식 :
    + 탐색 시작노드를 스택에 삽입후 방문처리
    + 스택의 최상단 노드에 방문처리를 하지 않은 노드가 있는지 탐색
      있다면 스택에 삽입후 방문처리
    + 방문처리를 하지 않은 인접한 노드가 없다면 스택의 최상단 노드를 삭제
    + 더이상 방문할 노드가 없을때까지 반복
    ```Python
    def dfs(graph, v, visited):
        #현재 노드를 방문처리
        visited[v] = True
        #현재 노드와 연결된 다른 노드를 재귀적으로 방문
        #스택과 유사한 구조를 가진 재귀함수를 통해 구현
        for i in graph[v]:
            if not visited[i]:
                dfs(graph, i, visited)
    
    graph = [
        [], #그래프의 경우 최상단 노드가 1에서부터 시작되는 경우가 많기 때문에 0번째 인덱스는 비움처리
        [2, 3, 8],
        [1, 7],
        [1, 4, 5],
        [3, 5],
        [3, 4],
        [7],
        [2, 6, 8],
        [1, 7]
    ]
    visited = [False] * 9 #모든 노드를 방문하지 않았음으로 초기화, 일반적으로 노드의 개수 + 1만큼 초기화

    dfs(graph, 1, visited)
    ```
---------------

## 4. BFS(Breadth-First Search)
+ 깊이 우선 탐색
+ 탐색뿐만 아니라 각 간선의 비용이 모두 동일하다는 가정하에 최단거리를 구하는데에도 사용
+ DFS에 비해 속도면에서의 성능이 좋음
+ 구현방식 :
    + DFS와 동일한 구조의 반복을 큐를 통해 구현
    ```Python
    from collections import deque

    def bfs(graph, v, visited):
        queue = deque([v]) #현재의 노드를 큐에 삽입
        visited[v] = True  #현재 노드를 방문처리
        while queue: #큐가 빌 때까지 반복
            vq = queue.popleft()
            for i in graph[vq]:
                if not visited[vq]:
                    queue.append(i)
                    visited[i] = True

    graph = [
        [], #그래프의 경우 최상단 노드가 1에서부터 시작되는 경우가 많기 때문에 0번째 인덱스는 비움처리
        [2, 3, 8],
        [1, 7],
        [1, 4, 5],
        [3, 5],
        [3, 4],
        [7],
        [2, 6, 8],
        [1, 7]
    ]
    visited = [False] * 9 #모든 노드를 방문하지 않았음으로 초기화, 일반적으로 노드의 개수 + 1만큼 초기화

    bfs(graph, 1, visited)
    ```
---------------